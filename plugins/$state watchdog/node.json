[
    {
        "id": "84e3502f.6ee37",
        "type": "function",
        "z": "9d52d40a.a63668",
        "name": "$state watchdog",
        "func": "// -------------------------------------------------------------------\n// this function provides a timeOut function to emulate the LWT functionality\n// for $state=\"lost\". on every received msg.state.$state it resets the timer\n// if the timer runs out it issues msg.state.$state=\"lost\" and a message to \n// the extra filed msg.state.resetReason\n// can be configured by:\n// msg.state.interval in seconds\n// -------------------------------------------------------------------\nvar timeout=120     // in seconds (set to 0 if you want to disable this feature)\nvar graceTime=60    // give a little extra to avoid false alarms\n\nvar status={fill:\"red\",shape:\"dot\",text:\"\"};\nif (msg.hasOwnProperty(\"state\") && msg.state.hasOwnProperty(\"interval\")) {\n    if (!Number(msg.state.interval).isNaN) {\n        timeout=Number(msg.state.interval)+graceTime; //*1.5 \n    } else {\n        status.text=\"[$state watchdog] msg.state.interval is NaN:\"+msg.state.interval;\n        node.error(status.text);\n        node.status(status);\n        return msg;\n    }\n}\nvar resetReason=\"device lost! No refresh the last \"+timeout-graceTime+\"sec\"\n\n// ------------------------------------------------------\n// emulate timeout for $state=\"lost\"\n// ------------------------------------------------------\nfunction mqttTimeout(arg) {\n    arg.node.send(arg.msg);\n}\n    \nif (timeout>0 && msg.hasOwnProperty(\"topic\")) {\n    // we have to keep track on existing timers\n    lostTimers = context.get(\"lostTimers\"); // allways memoryOnly as the timers do not extist after restart\n    if (lostTimers===undefined) {\n        lostTimers={};\n        context.set(\"lostTimers\",lostTimers);\n    }\n    if (lostTimers.hasOwnProperty(msg.topic)) { // timer exists so clear it first\n        clearTimeout(lostTimers[msg.topic].timer);\n    }\n    if (!lostTimers.hasOwnProperty(msg.topic)) lostTimers[msg.topic]={};\n    lostTimers[msg.topic].timeout=timeout;\n    lostTimers[msg.topic].timer=setTimeout(mqttTimeout, timeout*1000, \n        {\n            \"node\":node,\n            \"msg\":{\n                \"topic\":msg.topic,\n                \"state\":{\n                    \"$state\":\"lost\",\n                    \"resetReason\":resetReason\n                }\n                \n            }\n        }\n    );\n    node.status({fill:\"green\",shape:\"dot\",text:msg.topic+\"=\"+timeout-graceTime+\"s\"});\n}\n\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "x": 1321,
        "y": 85,
        "wires": [
            [
                "9d9d213d.09396"
            ]
        ],
        "icon": "node-red/swap.svg",
        "info": "# msg.state.$state watchdog\n## decription\nthis function provides a timeOut function (watchdog) to emulate the LWT functionality\nissueing $state=\"lost\" if a device did not update in time. \non every received msg.state.$state it resets the timer\nif the timer runs out it issues `msg.state.$state=\"lost\"` and a message to \nthe extra filed `msg.state.resetReason`\n\nyou can find more about the [homie convention device lifecyle here](https://homieiot.github.io/specification/#device-lifecycle).\n\n## how to use\n- place it in the main plugin list if you like to have a watchdog for every device with the same timeout\n- place it after a translator / data source if only some devices need a watchdog because they do not supprt mqtt LWT or similar techniques to detect offline devices and set the msg.state.$state correcty over the complete lifecycle.\n- place diffent watchdogs in the aquisition area behind translators if you need **individual timeout durations**.\n- edit the `timeout` variable in the code or\n- send msg.state.interval to set individual timeout by message\n\n## do do / issues\n- have to find out if a clearTimeout / setTimeout on every message is the most efficient way.\n- perhaps own code with one interval timer more efficient for a bigger number of devices\n\n## homie features\n- `$state` *string* current state of the device\n- `interval` *integer* in sec \n\n## extended features\n- `resetReason` *string* description that the device was flaged by the watchdog"
    }
]